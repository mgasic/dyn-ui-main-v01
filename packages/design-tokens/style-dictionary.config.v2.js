const StyleDictionary = require('style-dictionary');

// ============================================
// CUSTOM TRANSFORM: Shorter Token Names
// ============================================
StyleDictionary.registerTransform({
  name: 'name/dyn/short',
  type: 'name',
  transformer: (token) => {
    const path = token.path.slice(1); // Remove 'dyn' prefix
    let name = path.join('-');

    // Apply shortcuts for cleaner names
    const shortcuts = {
      'responsive-tabs-color-background': 'responsive-tabs-bg',
      'responsive-tabs-color-text': 'responsive-tabs-text',
      'responsive-tabs-typography-font-size': 'responsive-tabs-font-size',
      'responsive-tabs-typography-font-weight': 'responsive-tabs-font-weight',
      'responsive-tabs-typography-font-family': 'responsive-tabs-font-family',
      'color-background': 'bg',
      'color-text': 'text',
      'typography-font-size': 'font-size',
      'typography-font-weight': 'font-weight',
      'typography-font-family': 'font-family'
    };

    // Apply shortcuts
    Object.entries(shortcuts).forEach(([long, short]) => {
      name = name.replace(long, short);
    });

    return `dyn-${name}`;
  }
});

// ============================================
// CUSTOM TRANSFORM: Size with PX (Skip Weight)
// ============================================
StyleDictionary.registerTransform({
  name: 'size/px/clean',
  type: 'value',
  matcher: (token) => {
    // Only apply to size category, but NOT to font weights
    return token.path[0] === 'size' && !token.path.includes('weight');
  },
  transformer: (token) => {
    // If it's a number, add px. If it's already a string with units, leave it.
    const val = token.value;
    if (typeof val === 'number') return `${val}px`;
    if (typeof val === 'string' && /^\d+$/.test(val)) return `${val}px`;
    return val;
  }
});

// ============================================
// HELPER: Check if token is a dark theme variant
// ============================================
function isDarkThemeToken(token) {
  // A token is a dark variant only if its path explicitly contains darkTheme/darktheme
  return token.path.includes('darkTheme') || token.path.includes('darktheme');
}

// ============================================
// CUSTOM FORMAT: CSS with Dark Theme Support
// ============================================
StyleDictionary.registerFormat({
  name: 'css/variables-with-dark',
  formatter: ({ dictionary }) => {
    const tokens = dictionary.allTokens;

    const lightTokens = [];
    const darkOutputs = [];

    tokens.forEach(token => {
      const isDark = isDarkThemeToken(token);

      if (isDark) {
        // 1. It's an explicit dark variant token (e.g. background.darkTheme)
        const lightName = token.name
          .replace('-dark-theme-', '-')
          .replace('-darktheme-', '-');

        if (token.comment) darkOutputs.push(`    /* ${token.comment} */`);
        darkOutputs.push(`    --${lightName}: ${token.value};`);
      }
      else {
        // 2. It's a normal token (Light mode)
        if (token.comment) lightTokens.push(`  /* ${token.comment} */`);
        lightTokens.push(`  --${token.name}: ${token.value};`);

        // 3. If it ALSO has the nested darkTheme property (Option B style), add to dark too
        // We only do this if it's NOT already handled by a child token (to prevent duplication)
        // Actually, if we use Option B style, we don't need explicit dark tokens.
        if (token.darkTheme && token.darkTheme.value) {
          if (token.comment) darkOutputs.push(`    /* ${token.comment} (variant) */`);
          darkOutputs.push(`    --${token.name}: ${token.darkTheme.value};`);
        }
      }
    });

    let output = `/* ============================================
   AUTO-GENERATED by Style Dictionary
   DO NOT EDIT DIRECTLY
   Source: tokens/**/*.json
   ============================================ */

`;

    // Light theme (default)
    output += `:root {\n${lightTokens.join('\n')}\n}\n\n`;

    // Dark theme (media query + classes)
    if (darkOutputs.length > 0) {
      // Use Set to remove any remaining accidental duplications by key
      const uniqueDarkLines = Array.from(new Set(darkOutputs));
      const darkContent = uniqueDarkLines.join('\n');

      output += `/* Dark Theme Support (Media Query + Classes) */\n`;
      output += `@media (prefers-color-scheme: dark) {\n  :root {\n${darkContent}\n  }\n}\n\n`;
      output += `[data-theme='dark'],\n.theme-dark {\n${darkContent}\n}\n`;
    }

    return output;
  }
});


// ============================================
// MAIN CONFIGURATION
// ============================================
module.exports = {
  source: ['tokens/**/*.json'],

  platforms: {
    // Component-specific CSS → styles/components/
    components: {
      transformGroup: 'css',
      transforms: [
        'attribute/cti',
        'name/dyn/short',
        'time/seconds',
        'content/icon',
        'size/px/clean',
        'color/css'
      ],
      buildPath: 'styles/components/',
      files: [
        {
          destination: 'badge.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.includes('badge.json')
        },
        {
          destination: 'avatar.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.includes('avatar.json')
        },
        {
          destination: 'responsive-tabs.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.includes('responsive-tabs.json')
        },
        {
          destination: 'table.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.includes('table.json')
        }
      ]
    },

    // Foundation tokens → styles/foundations/
    foundations: {
      transformGroup: 'css',
      transforms: [
        'attribute/cti',
        'name/dyn/short',
        'time/seconds',
        'content/icon',
        'size/px/clean',
        'color/css'
      ],
      buildPath: 'styles/foundations/',
      files: [
        {
          destination: 'index.css',
          format: 'css/variables-with-dark',
          filter: (token) => {
            // All foundation tokens (not component-specific)
            return !token.filePath.includes('badge.json') &&
              !token.filePath.includes('avatar.json') &&
              !token.filePath.includes('responsive-tabs.json') &&
              !token.filePath.includes('table.json');
          }
        }
      ]
    },

    // Bonus: JavaScript/TypeScript output
    js: {
      transformGroup: 'js',
      buildPath: 'build/js/',
      files: [
        {
          destination: 'tokens.js',
          format: 'javascript/es6'
        }
      ]
    },

    // Bonus: TypeScript types
    ts: {
      transformGroup: 'js',
      buildPath: 'build/ts/',
      files: [
        {
          destination: 'tokens.d.ts',
          format: 'typescript/es6-declarations'
        }
      ]
    }
  }
};
