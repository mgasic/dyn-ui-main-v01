const StyleDictionary = require('style-dictionary');

// ============================================
// CUSTOM TRANSFORM: Shorter Token Names
// ============================================
StyleDictionary.registerTransform({
  name: 'name/dyn/short',
  type: 'name',
  transformer: (token) => {
    const path = token.path.slice(1); // Remove 'dyn' prefix
    let name = path.join('-');

    // Apply shortcuts for cleaner names
    const shortcuts = {
      'responsive-tabs-color-background': 'responsive-tabs-bg',
      'responsive-tabs-color-text': 'responsive-tabs-text',
      'typography-font': 'size-font',
      'color-background': 'bg',
      'color-text': 'text'
    };

    // Apply shortcuts
    Object.entries(shortcuts).forEach(([long, short]) => {
      name = name.replace(long, short);
    });

    return `dyn-${name}`;
  }
});

// ============================================
// CUSTOM TRANSFORM: Size with PX (Skip Weight)
// ============================================
StyleDictionary.registerTransform({
  name: 'size/px/clean',
  type: 'value',
  matcher: (token) => {
    // Only apply to size category, but NOT to font weights
    return token.path[0] === 'size' && !token.path.includes('weight');
  },
  transformer: (token) => {
    // If it's a number, add px. If it's already a string with units, leave it.
    const val = token.value;
    if (typeof val === 'number') return `${val}px`;
    if (typeof val === 'string' && /^\d+$/.test(val)) return `${val}px`;
    return val;
  }
});

// ============================================
// HELPER: Check if token is a dark theme variant
// ============================================
function isDarkThemeToken(token) {
  // A token is a dark variant only if its path explicitly contains darkTheme/darktheme
  return token.path.includes('darkTheme') || token.path.includes('darktheme');
}

// ============================================
// CUSTOM FORMAT: CSS with Dark Theme Support
// ============================================
StyleDictionary.registerFormat({
  name: 'css/variables-with-dark',
  formatter: ({ dictionary, options }) => {
    const formatValue = (token) => {
      const { outputReferences } = options;
      // If outputReferences is true and the token relies on aliases, use var()
      if (outputReferences && dictionary.usesReference(token.original.value)) {
        const refs = dictionary.getReferences(token.original.value);
        // Simple case: direct alias
        const ref = refs[0];
        if (ref) {
          return `var(--${ref.name})`;
        }
      }
      return token.value;
    };

    const tokens = dictionary.allTokens;

    const lightTokens = [];
    const darkOutputs = [];

    tokens.forEach(token => {
      const isDark = isDarkThemeToken(token);
      const value = formatValue(token);

      if (isDark) {
        // 1. It's an explicit dark variant token (e.g. background.darkTheme)
        const lightName = token.name
          .replace('-dark-theme-', '-')
          .replace('-darktheme-', '-');

        if (token.comment) darkOutputs.push(`    /* ${token.comment} */`);
        darkOutputs.push(`    --${lightName}: ${token.value};`); // Dark variants typically hardcoded or their own ref
      }
      else {
        // 2. It's a normal token (Light mode)
        if (token.comment) lightTokens.push(`  /* ${token.comment} */`);
        lightTokens.push(`  --${token.name}: ${value};`);

        // 3. If it ALSO has the nested darkTheme property (Option B style), add to dark too
        if (token.darkTheme && token.darkTheme.value) {
          if (token.comment) darkOutputs.push(`    /* ${token.comment} (variant) */`);
          // For dark theme override, we usually want the resolved value of the dark override
          // We can assume it's resolved already or needs referencing logic too (skipping ref for now for simplicity)
          darkOutputs.push(`    --${token.name}: ${token.darkTheme.value};`);
        }
      }
    });

    let output = `/* ============================================
   AUTO-GENERATED by Style Dictionary
   DO NOT EDIT DIRECTLY
   Source: tokens/**
   ============================================ */

`;

    // Light theme (default)
    output += `:root {\n${lightTokens.join('\n')}\n}\n\n`;

    // Dark theme (media query + classes)
    if (darkOutputs.length > 0) {
      // Use Set to remove any remaining accidental duplications by key
      const uniqueDarkLines = Array.from(new Set(darkOutputs));
      const darkContent = uniqueDarkLines.join('\n');

      output += `/* Dark Theme Support (Media Query + Classes) */\n`;
      output += `@media (prefers-color-scheme: dark) {\n  :root {\n${darkContent}\n  }\n}\n\n`;
      output += `[data-theme='dark'],\n.theme-dark {\n${darkContent}\n}\n`;
    }

    return output;
  }
});


// ============================================
// MAIN CONFIGURATION
// ============================================
module.exports = {
  source: ['tokens/**/*.json'],

  platforms: {
    // Component-specific CSS → styles/components/
    components: {
      transformGroup: 'css',
      transforms: [
        'attribute/cti',
        'name/dyn/short',
        'time/seconds',
        'content/icon',
        'size/px/clean',
        'color/css'
      ],
      buildPath: 'styles/components/',
      files: [
        {
          destination: 'badge.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/badge.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'avatar.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/avatar.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'responsive-tabs.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/responsive-tabs.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'table.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/table.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'checkbox.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/checkbox.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'date-picker.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/date-picker.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'icon.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/icon.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'list-view.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/list-view.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'sidebar.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/sidebar.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'stepper.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/stepper.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'theme-switcher.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/theme-switcher.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'tree-view.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/tree-view.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'box.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/box.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'flex.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/flex.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'stack.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/stack.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'container.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/container.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'button.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/button.json'),
          options: { outputReferences: true }
        },
        {
          destination: 'field-container.css',
          format: 'css/variables-with-dark',
          filter: (token) => token.filePath.replace(/\\/g, '/').endsWith('/field-container.json'),
          options: { outputReferences: true }
        }
      ]
    },

    // Foundation tokens → styles/foundations/
    foundations: {
      transformGroup: 'css',
      transforms: [
        'attribute/cti',
        'name/dyn/short',
        'time/seconds',
        'content/icon',
        'size/px/clean',
        'color/css'
      ],
      buildPath: 'styles/foundations/',
      files: [
        {
          destination: 'index.css',
          format: 'css/variables-with-dark',
          filter: (token) => {
            const normalizedPath = token.filePath.replace(/\\/g, '/');
            // All foundation tokens (not component-specific)
            return !normalizedPath.endsWith('/badge.json') &&
              !normalizedPath.endsWith('/avatar.json') &&
              !normalizedPath.endsWith('/responsive-tabs.json') &&
              !normalizedPath.endsWith('/table.json') &&
              !normalizedPath.endsWith('/box.json') &&
              !normalizedPath.endsWith('/flex.json') &&
              !normalizedPath.endsWith('/stack.json') &&
              !normalizedPath.endsWith('/container.json') &&
              !normalizedPath.endsWith('/field-container.json');
          }
        }
      ]
    },

    // Bonus: JavaScript/TypeScript output
    js: {
      transformGroup: 'js',
      buildPath: 'build/js/',
      files: [
        {
          destination: 'tokens.js',
          format: 'javascript/es6'
        }
      ]
    },

    // Bonus: TypeScript types
    ts: {
      transformGroup: 'js',
      buildPath: 'build/ts/',
      files: [
        {
          destination: 'tokens.d.ts',
          format: 'typescript/es6-declarations'
        }
      ]
    }
  }
};
